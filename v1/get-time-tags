#! /usr/bin/env python3

import subprocess
import datetime
from binascii import b2a_uu 


TAG_TIME_GETTERS_BY_REPO_TYPE = {
    'git': """
tags=`git tag`
for tag in $tags; do
    sha=`git rev-list $tag | head -n 1`
    unix_timestamp=`git rev-list --format=%ct --max-count=1 $tag | sed -n 2p`
    echo $tag","$sha","$unix_timestamp
done
""",
    'hg': """
while read -r tag_line;
do
  tag_line_array=($tag_line);
  tag=${tag_line_array[0]};
  changeset=${tag_line_array[1]};

  if [ $tag == "tip" ]
  then
    continue
  fi

  time=`hg log -r $changeset | grep "date: " | cut -d " " -f 2-`

  echo $tag","$changeset","$time

done <<< "`hg tags`"
"""
}


def get_repo_type():
    for repo_type in TAG_TIME_GETTERS_BY_REPO_TYPE:
        returncode = subprocess.call([repo_type, 'status'],
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.DEVNULL)
        if not returncode:
            return repo_type
    raise EnvironmentError('No repository found in current directory')


def build_time_tag_list(time_tag_string, repo_name=None, repo_type=None):
    time_tag_list = []
    max_version_tuple_length = 0
    for row in time_tag_string.split('\n'): 
        tag, sha, time_str = row.split(',')
        pre_release = False
        for letter in ('a', 'b', 'c'):
            if letter in tag:
                pre_release = True
        # Do not include alphas, betas, release candidates
        if pre_release:
            continue

        unix_ts = get_unix_ts(time_str.strip(), repo_type)
        version_tuple = get_version_tuple(tag, repo_name)
        tuple_length = len(version_tuple)
        if tuple_length > max_version_tuple_length:
            max_version_tuple_length = tuple_length
        time_tag_list.append((unix_ts, version_tuple, tag))

    convert_time_tag_version_tuples(time_tag_list, max_version_tuple_length)

    return time_tag_list


def get_version_tuple(version_str, repo_name=None):
    if repo_name == 'python':
        version_str = version_str.lstrip('v')

        tup = tuple(map(int, version_str.split('.')))
        return tup
    return (version_str,)


def get_unix_ts(time_str, repo_type=None):
    unix_ts = time_str
    if repo_type == 'hg':
        pattern = "%a %b %d %H:%M:%S %Y %z"
        dt = datetime.datetime.strptime(time_str, pattern)
        unix_ts = int(dt.timestamp())

    return unix_ts


def list_get(list_, index, default=None):
    try:
        return list_[index]
    except IndexError:
        return default


def calculate_version_value(version_tuple, min_max_list):
    version_value = 0
    len_min_max_list = len(min_max_list)
    for i in range(len_min_max_list):
        min_, max_ = min_max_list[i]
        part = version_tuple[i]
        part_value = (part - min_) / (max_ - min_)
        part_value_coeff = 10 ** (len_min_max_list - i)
        version_value += part_value_coeff * part_value

    return version_value


def resize_version_tuple(version_tuple, min_max_list):
    part_list = []
    len_min_max_list = len(min_max_list)
    for i in range(len_min_max_list):
        min_, max_ = min_max_list[i]
        part = list_get(version_tuple, i, min_)
        part_list.append(part)

    return tuple(part_list)


def convert_time_tag_version_tuples(time_tag_list, max_version_tuple_length):
    min_max_list = [[0, 0] for _ in range(max_version_tuple_length)]

    # Get max and min for each version part (eg. major, minor, patch)
    for _, version_tuple, _ in time_tag_list:
        for i, version_part in enumerate(version_tuple):
            min_max = min_max_list[i]
            if version_part <  min_max[0]:
                min_max[0] = version_part
            if version_part > min_max[1]:
                min_max[1] = version_part

    for i, (unix_ts, version_tuple, version_str) in enumerate(time_tag_list):
        version_tuple = resize_version_tuple(version_tuple, min_max_list)
        version_value = calculate_version_value(version_tuple, min_max_list)
        time_tag_list[i] = (unix_ts, version_value, version_tuple,  version_str)


def plot_tags():
    repo_type = get_repo_type()
    print('Repository type: {}'.format(repo_type))
    tag_time_getter_cmd = TAG_TIME_GETTERS_BY_REPO_TYPE[repo_type]
    print('Reading tags from repository...', end='', flush=True) 
    result_string = subprocess.check_output(tag_time_getter_cmd, shell=True)
    result_string = result_string.decode('UTF8')
    print('done.', flush=True)

    time_tag_list = build_time_tag_list(result_string, repo_type=repo_type)
    
    print(time_tag_list)


if __name__ == '__main__':
    plot_tags()
